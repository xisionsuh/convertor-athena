/**
 * Export Document Tool - ëŒ€í™” ë° ë¬¸ì„œ ë‚´ë³´ë‚´ê¸°
 * ëŒ€í™”, íšŒì˜ë¡, í”„ë¡œì íŠ¸ ìë£Œë¥¼ PDF/Markdown/HTMLë¡œ ë‚´ë³´ë‚´ëŠ” ê¸°ëŠ¥
 */

import { logger } from '../../utils/logger.js';
import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';

/**
 * ë¬¸ì„œ ë‚´ë³´ë‚´ê¸° ë„êµ¬ ìƒì„±
 * @param {Object} options - ì„¤ì • ì˜µì…˜
 * @returns {Array<Object>} MCP Tool ê°ì²´ ë°°ì—´
 */
export function createExportDocumentTools(options = {}) {
  const {
    dbPath = './athena-data/athena.db',
    workspaceRoot = process.cwd(),
    outputDir = 'exports'
  } = options;

  const db = new Database(dbPath);

  // ë‚´ë³´ë‚´ê¸° ë””ë ‰í† ë¦¬ ìƒì„±
  const fullOutputDir = path.join(workspaceRoot, outputDir);
  if (!fs.existsSync(fullOutputDir)) {
    fs.mkdirSync(fullOutputDir, { recursive: true });
  }

  // ë§ˆí¬ë‹¤ìš´ì„ HTMLë¡œ ë³€í™˜ (ê°„ë‹¨í•œ ë³€í™˜)
  const markdownToHtml = (markdown) => {
    return markdown
      // í—¤ë”
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      // êµµê²Œ/ê¸°ìš¸ì„
      .replace(/\*\*\*(.*?)\*\*\*/gim, '<strong><em>$1</em></strong>')
      .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/gim, '<em>$1</em>')
      // ì½”ë“œ ë¸”ë¡
      .replace(/```(\w+)?\n([\s\S]*?)```/gim, '<pre><code class="language-$1">$2</code></pre>')
      .replace(/`(.*?)`/gim, '<code>$1</code>')
      // ë§í¬
      .replace(/\[([^\]]+)\]\(([^)]+)\)/gim, '<a href="$2">$1</a>')
      // ë¦¬ìŠ¤íŠ¸
      .replace(/^\s*[-*]\s+(.*)$/gim, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
      .replace(/^\s*\d+\.\s+(.*)$/gim, '<li>$1</li>')
      // ì¤„ë°”ê¿ˆ
      .replace(/\n\n/g, '</p><p>')
      .replace(/\n/g, '<br>');
  };

  // HTML ë¬¸ì„œ í…œí”Œë¦¿
  const createHtmlDocument = (title, content, options = {}) => {
    const { author = 'Athena AI', date = new Date().toLocaleDateString('ko-KR'), theme = 'light' } = options;

    const themeStyles = theme === 'dark' ? `
      body { background: #1a1a2e; color: #eee; }
      h1, h2, h3 { color: #00d9ff; }
      pre { background: #16213e; }
      .message.user { background: #0f3460; }
      .message.assistant { background: #1a1a2e; border: 1px solid #333; }
    ` : `
      body { background: #fff; color: #333; }
      h1, h2, h3 { color: #2c3e50; }
      pre { background: #f4f4f4; }
      .message.user { background: #e3f2fd; }
      .message.assistant { background: #f5f5f5; }
    `;

    return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6; padding: 2rem; max-width: 900px; margin: 0 auto;
    }
    ${themeStyles}
    h1 { margin-bottom: 0.5rem; }
    .meta { color: #888; margin-bottom: 2rem; font-size: 0.9rem; }
    .message { padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }
    .message .role { font-weight: bold; margin-bottom: 0.5rem; }
    .message .time { font-size: 0.8rem; color: #888; }
    pre { padding: 1rem; border-radius: 4px; overflow-x: auto; margin: 1rem 0; }
    code { font-family: 'Fira Code', monospace; font-size: 0.9em; }
    ul, ol { margin-left: 1.5rem; margin-bottom: 1rem; }
    p { margin-bottom: 1rem; }
    .footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #ddd; font-size: 0.8rem; color: #888; }
  </style>
</head>
<body>
  <h1>${title}</h1>
  <div class="meta">
    <span>ì‘ì„±ì: ${author}</span> |
    <span>ë‚ ì§œ: ${date}</span>
  </div>
  <div class="content">
    ${content}
  </div>
  <div class="footer">
    Generated by Athena AI â€¢ ${new Date().toLocaleString('ko-KR')}
  </div>
</body>
</html>`;
  };

  return [
    // ì„¸ì…˜ ëŒ€í™” ë‚´ë³´ë‚´ê¸°
    {
      name: 'export_conversation',
      description: 'ì±„íŒ… ì„¸ì…˜ì˜ ëŒ€í™” ë‚´ìš©ì„ íŒŒì¼ë¡œ ë‚´ë³´ëƒ…ë‹ˆë‹¤.',
      inputSchema: {
        type: 'object',
        properties: {
          sessionId: {
            type: 'string',
            description: 'ë‚´ë³´ë‚¼ ì„¸ì…˜ ID'
          },
          format: {
            type: 'string',
            enum: ['markdown', 'html', 'json', 'txt'],
            description: 'ì¶œë ¥ í˜•ì‹',
            default: 'markdown'
          },
          title: {
            type: 'string',
            description: 'ë¬¸ì„œ ì œëª© (ê¸°ë³¸: ì„¸ì…˜ ì œëª©)'
          },
          includeMetadata: {
            type: 'boolean',
            description: 'ë©”íƒ€ë°ì´í„° í¬í•¨ ì—¬ë¶€',
            default: true
          },
          theme: {
            type: 'string',
            enum: ['light', 'dark'],
            description: 'HTML í…Œë§ˆ',
            default: 'light'
          }
        },
        required: ['sessionId']
      },
      execute: async (args) => {
        const {
          sessionId,
          format = 'markdown',
          title,
          includeMetadata = true,
          theme = 'light'
        } = args;

        try {
          // ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
          const session = db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId);
          if (!session) {
            throw new Error('ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
          }

          // ë©”ì‹œì§€ ì¡°íšŒ
          const messages = db.prepare(`
            SELECT * FROM short_term_memory
            WHERE session_id = ?
            ORDER BY created_at ASC
          `).all(sessionId);

          if (messages.length === 0) {
            throw new Error('ë‚´ë³´ë‚¼ ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤');
          }

          const docTitle = title || session.title || `ëŒ€í™” ê¸°ë¡ - ${sessionId}`;
          let content = '';
          let outputPath = '';
          const timestamp = Date.now();

          switch (format) {
            case 'markdown':
              content = `# ${docTitle}\n\n`;
              if (includeMetadata) {
                content += `> ì„¸ì…˜ ID: ${sessionId}\n`;
                content += `> ìƒì„±ì¼: ${session.created_at}\n\n`;
                content += `---\n\n`;
              }

              messages.forEach(msg => {
                const role = msg.message_type === 'user' ? 'ğŸ‘¤ ì‚¬ìš©ì' : 'ğŸ¤– Athena';
                const time = new Date(msg.created_at).toLocaleTimeString('ko-KR');
                content += `### ${role} (${time})\n\n`;
                content += `${msg.content}\n\n`;
              });

              outputPath = path.join(fullOutputDir, `conversation_${timestamp}.md`);
              break;

            case 'html':
              let htmlContent = '';
              messages.forEach(msg => {
                const role = msg.message_type === 'user' ? 'user' : 'assistant';
                const roleName = role === 'user' ? 'ğŸ‘¤ ì‚¬ìš©ì' : 'ğŸ¤– Athena';
                const time = new Date(msg.created_at).toLocaleTimeString('ko-KR');
                const contentHtml = markdownToHtml(msg.content);

                htmlContent += `<div class="message ${role}">
                  <div class="role">${roleName} <span class="time">${time}</span></div>
                  <div class="body"><p>${contentHtml}</p></div>
                </div>\n`;
              });

              content = createHtmlDocument(docTitle, htmlContent, { theme });
              outputPath = path.join(fullOutputDir, `conversation_${timestamp}.html`);
              break;

            case 'json':
              content = JSON.stringify({
                title: docTitle,
                sessionId,
                createdAt: session.created_at,
                exportedAt: new Date().toISOString(),
                messages: messages.map(m => ({
                  role: m.message_type,
                  content: m.content,
                  timestamp: m.created_at,
                  metadata: m.metadata ? JSON.parse(m.metadata) : null
                }))
              }, null, 2);
              outputPath = path.join(fullOutputDir, `conversation_${timestamp}.json`);
              break;

            case 'txt':
              content = `${docTitle}\n${'='.repeat(docTitle.length)}\n\n`;
              messages.forEach(msg => {
                const role = msg.message_type === 'user' ? '[ì‚¬ìš©ì]' : '[Athena]';
                const time = new Date(msg.created_at).toLocaleTimeString('ko-KR');
                content += `${role} (${time})\n`;
                content += `${msg.content}\n\n`;
                content += `-`.repeat(50) + '\n\n';
              });
              outputPath = path.join(fullOutputDir, `conversation_${timestamp}.txt`);
              break;
          }

          fs.writeFileSync(outputPath, content, 'utf-8');

          logger.info('ëŒ€í™” ë‚´ë³´ë‚´ê¸° ì™„ë£Œ', { sessionId, format, outputPath });

          return {
            success: true,
            filePath: path.relative(workspaceRoot, outputPath),
            absolutePath: outputPath,
            format,
            messagesCount: messages.length,
            fileSize: fs.statSync(outputPath).size
          };

        } catch (error) {
          logger.error('ëŒ€í™” ë‚´ë³´ë‚´ê¸° ì˜¤ë¥˜', error);
          throw new Error(`ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ${error.message}`);
        }
      }
    },

    // íšŒì˜ë¡ ë‚´ë³´ë‚´ê¸°
    {
      name: 'export_meeting_minutes',
      description: 'íšŒì˜ë¡ í˜•ì‹ìœ¼ë¡œ ëŒ€í™”ë¥¼ ì •ë¦¬í•˜ì—¬ ë‚´ë³´ëƒ…ë‹ˆë‹¤.',
      inputSchema: {
        type: 'object',
        properties: {
          sessionId: {
            type: 'string',
            description: 'ì„¸ì…˜ ID'
          },
          meetingInfo: {
            type: 'object',
            description: 'íšŒì˜ ì •ë³´',
            properties: {
              title: { type: 'string', description: 'íšŒì˜ ì œëª©' },
              date: { type: 'string', description: 'íšŒì˜ ì¼ì‹œ' },
              participants: { type: 'array', items: { type: 'string' }, description: 'ì°¸ì„ì' },
              location: { type: 'string', description: 'ì¥ì†Œ' }
            }
          },
          format: {
            type: 'string',
            enum: ['markdown', 'html'],
            default: 'markdown'
          }
        },
        required: ['sessionId']
      },
      execute: async (args) => {
        const { sessionId, meetingInfo = {}, format = 'markdown' } = args;

        try {
          const session = db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId);
          const messages = db.prepare(`
            SELECT * FROM short_term_memory
            WHERE session_id = ?
            ORDER BY created_at ASC
          `).all(sessionId);

          const title = meetingInfo.title || session?.title || 'íšŒì˜ë¡';
          const date = meetingInfo.date || new Date().toLocaleDateString('ko-KR');
          const participants = meetingInfo.participants || ['ì°¸ì„ì ì •ë³´ ì—†ìŒ'];
          const location = meetingInfo.location || 'ì˜¨ë¼ì¸';

          let content = '';

          if (format === 'markdown') {
            content = `# ğŸ“‹ ${title}\n\n`;
            content += `## íšŒì˜ ì •ë³´\n\n`;
            content += `| í•­ëª© | ë‚´ìš© |\n`;
            content += `|------|------|\n`;
            content += `| ì¼ì‹œ | ${date} |\n`;
            content += `| ì¥ì†Œ | ${location} |\n`;
            content += `| ì°¸ì„ì | ${participants.join(', ')} |\n\n`;
            content += `---\n\n`;
            content += `## íšŒì˜ ë‚´ìš©\n\n`;

            messages.forEach((msg, index) => {
              if (msg.message_type === 'assistant') {
                content += `### ${index + 1}. AI ë¶„ì„\n\n`;
                content += `${msg.content}\n\n`;
              } else {
                content += `**ì§ˆë¬¸/ìš”ì²­:** ${msg.content}\n\n`;
              }
            });

            content += `---\n\n`;
            content += `*ì´ íšŒì˜ë¡ì€ Athena AIì— ì˜í•´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.*\n`;
            content += `*ìƒì„± ì‹œê°„: ${new Date().toLocaleString('ko-KR')}*\n`;
          } else {
            let htmlContent = `
              <table class="meeting-info" style="width:100%;border-collapse:collapse;margin-bottom:2rem;">
                <tr><th style="text-align:left;padding:0.5rem;border:1px solid #ddd;background:#f5f5f5;">ì¼ì‹œ</th><td style="padding:0.5rem;border:1px solid #ddd;">${date}</td></tr>
                <tr><th style="text-align:left;padding:0.5rem;border:1px solid #ddd;background:#f5f5f5;">ì¥ì†Œ</th><td style="padding:0.5rem;border:1px solid #ddd;">${location}</td></tr>
                <tr><th style="text-align:left;padding:0.5rem;border:1px solid #ddd;background:#f5f5f5;">ì°¸ì„ì</th><td style="padding:0.5rem;border:1px solid #ddd;">${participants.join(', ')}</td></tr>
              </table>
              <h2>íšŒì˜ ë‚´ìš©</h2>
            `;

            messages.forEach((msg, index) => {
              if (msg.message_type === 'assistant') {
                htmlContent += `<h3>${index + 1}. AI ë¶„ì„</h3><p>${markdownToHtml(msg.content)}</p>`;
              } else {
                htmlContent += `<p><strong>ì§ˆë¬¸/ìš”ì²­:</strong> ${msg.content}</p>`;
              }
            });

            content = createHtmlDocument(title, htmlContent);
          }

          const timestamp = Date.now();
          const ext = format === 'markdown' ? 'md' : 'html';
          const outputPath = path.join(fullOutputDir, `meeting_minutes_${timestamp}.${ext}`);
          fs.writeFileSync(outputPath, content, 'utf-8');

          return {
            success: true,
            filePath: path.relative(workspaceRoot, outputPath),
            format,
            title
          };

        } catch (error) {
          logger.error('íšŒì˜ë¡ ë‚´ë³´ë‚´ê¸° ì˜¤ë¥˜', error);
          throw new Error(`ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ${error.message}`);
        }
      }
    },

    // í”„ë¡œì íŠ¸ ìë£Œ ë‚´ë³´ë‚´ê¸°
    {
      name: 'export_project_materials',
      description: 'í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ìë£Œë¥¼ í•˜ë‚˜ì˜ ë¬¸ì„œë¡œ ë‚´ë³´ëƒ…ë‹ˆë‹¤.',
      inputSchema: {
        type: 'object',
        properties: {
          projectId: {
            type: 'string',
            description: 'í”„ë¡œì íŠ¸ ID'
          },
          format: {
            type: 'string',
            enum: ['markdown', 'html'],
            default: 'markdown'
          },
          includeContexts: {
            type: 'boolean',
            description: 'ì»¨í…ìŠ¤íŠ¸ í¬í•¨ ì—¬ë¶€',
            default: true
          },
          includeResources: {
            type: 'boolean',
            description: 'ë¦¬ì†ŒìŠ¤ í¬í•¨ ì—¬ë¶€',
            default: true
          }
        },
        required: ['projectId']
      },
      execute: async (args) => {
        const { projectId, format = 'markdown', includeContexts = true, includeResources = true } = args;

        try {
          // í”„ë¡œì íŠ¸ ì •ë³´
          const project = db.prepare('SELECT * FROM projects WHERE id = ?').get(projectId);
          if (!project) {
            throw new Error('í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
          }

          let content = '';
          const title = `${project.name} - í”„ë¡œì íŠ¸ ìë£Œ`;

          if (format === 'markdown') {
            content = `# ğŸ“ ${title}\n\n`;
            content += `> ${project.description || 'ì„¤ëª… ì—†ìŒ'}\n\n`;
            content += `ìƒì„±ì¼: ${project.created_at}\n\n`;
            content += `---\n\n`;

            if (includeContexts) {
              const contexts = db.prepare(`
                SELECT * FROM project_context
                WHERE project_id = ?
                ORDER BY importance DESC, created_at DESC
              `).all(projectId);

              if (contexts.length > 0) {
                content += `## ì»¨í…ìŠ¤íŠ¸ (${contexts.length}ê°œ)\n\n`;
                contexts.forEach((ctx, i) => {
                  content += `### ${i + 1}. ${ctx.title}\n`;
                  content += `- ìœ í˜•: ${ctx.context_type}\n`;
                  content += `- ì¤‘ìš”ë„: ${ctx.importance}/10\n\n`;
                  content += `${ctx.content}\n\n`;
                  content += `---\n\n`;
                });
              }
            }

            if (includeResources) {
              const resources = db.prepare(`
                SELECT * FROM project_resources
                WHERE project_id = ?
                ORDER BY created_at DESC
              `).all(projectId);

              if (resources.length > 0) {
                content += `## ë¦¬ì†ŒìŠ¤ (${resources.length}ê°œ)\n\n`;
                resources.forEach((res, i) => {
                  content += `### ${i + 1}. ${res.title}\n`;
                  content += `- ìœ í˜•: ${res.resource_type}\n`;
                  if (res.file_path) {
                    content += `- íŒŒì¼: ${res.file_path}\n`;
                  }
                  content += `\n${res.content || '(ë‚´ìš© ì—†ìŒ)'}\n\n`;
                  content += `---\n\n`;
                });
              }
            }
          } else {
            // HTML í˜•ì‹
            let htmlContent = `<p><em>${project.description || 'ì„¤ëª… ì—†ìŒ'}</em></p>`;

            if (includeContexts) {
              const contexts = db.prepare(`
                SELECT * FROM project_context WHERE project_id = ? ORDER BY importance DESC
              `).all(projectId);

              if (contexts.length > 0) {
                htmlContent += `<h2>ì»¨í…ìŠ¤íŠ¸ (${contexts.length}ê°œ)</h2>`;
                contexts.forEach((ctx, i) => {
                  htmlContent += `
                    <div style="margin-bottom:1.5rem;padding:1rem;border:1px solid #ddd;border-radius:8px;">
                      <h3>${i + 1}. ${ctx.title}</h3>
                      <p style="color:#666;font-size:0.9em;">ìœ í˜•: ${ctx.context_type} | ì¤‘ìš”ë„: ${ctx.importance}/10</p>
                      <p>${markdownToHtml(ctx.content)}</p>
                    </div>
                  `;
                });
              }
            }

            content = createHtmlDocument(title, htmlContent);
          }

          const timestamp = Date.now();
          const ext = format === 'markdown' ? 'md' : 'html';
          const outputPath = path.join(fullOutputDir, `project_${projectId}_${timestamp}.${ext}`);
          fs.writeFileSync(outputPath, content, 'utf-8');

          return {
            success: true,
            filePath: path.relative(workspaceRoot, outputPath),
            format,
            projectName: project.name
          };

        } catch (error) {
          logger.error('í”„ë¡œì íŠ¸ ë‚´ë³´ë‚´ê¸° ì˜¤ë¥˜', error);
          throw new Error(`ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ${error.message}`);
        }
      }
    },

    // ì»¤ìŠ¤í…€ ë¬¸ì„œ ìƒì„±
    {
      name: 'create_document',
      description: 'ë§ˆí¬ë‹¤ìš´ ë˜ëŠ” HTML ë¬¸ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.',
      inputSchema: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: 'ë¬¸ì„œ ì œëª©'
          },
          content: {
            type: 'string',
            description: 'ë¬¸ì„œ ë‚´ìš© (ë§ˆí¬ë‹¤ìš´)'
          },
          format: {
            type: 'string',
            enum: ['markdown', 'html'],
            default: 'markdown'
          },
          filename: {
            type: 'string',
            description: 'íŒŒì¼ëª… (í™•ì¥ì ì œì™¸)'
          },
          author: {
            type: 'string',
            description: 'ì‘ì„±ì',
            default: 'Athena AI'
          }
        },
        required: ['title', 'content']
      },
      execute: async (args) => {
        const { title, content, format = 'markdown', filename, author = 'Athena AI' } = args;

        try {
          let fileContent = '';
          const timestamp = Date.now();
          const baseName = filename || `document_${timestamp}`;

          if (format === 'markdown') {
            fileContent = `# ${title}\n\n`;
            fileContent += `> ì‘ì„±ì: ${author}\n`;
            fileContent += `> ì‘ì„±ì¼: ${new Date().toLocaleDateString('ko-KR')}\n\n`;
            fileContent += `---\n\n`;
            fileContent += content;
          } else {
            const htmlContent = markdownToHtml(content);
            fileContent = createHtmlDocument(title, `<p>${htmlContent}</p>`, { author });
          }

          const ext = format === 'markdown' ? 'md' : 'html';
          const outputPath = path.join(fullOutputDir, `${baseName}.${ext}`);
          fs.writeFileSync(outputPath, fileContent, 'utf-8');

          return {
            success: true,
            filePath: path.relative(workspaceRoot, outputPath),
            format,
            title
          };

        } catch (error) {
          logger.error('ë¬¸ì„œ ìƒì„± ì˜¤ë¥˜', error);
          throw new Error(`ë¬¸ì„œ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
        }
      }
    },

    // ë‚´ë³´ë‚´ê¸° ëª©ë¡ ì¡°íšŒ
    {
      name: 'list_exports',
      description: 'ë‚´ë³´ë‚´ê¸°ëœ íŒŒì¼ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.',
      inputSchema: {
        type: 'object',
        properties: {
          format: {
            type: 'string',
            description: 'í˜•ì‹ë³„ í•„í„°ë§ (md, html, json, txt)'
          },
          limit: {
            type: 'number',
            default: 20
          }
        }
      },
      execute: async (args) => {
        const { format, limit = 20 } = args;

        try {
          const files = fs.readdirSync(fullOutputDir)
            .filter(f => !format || f.endsWith(`.${format}`))
            .map(f => {
              const filePath = path.join(fullOutputDir, f);
              const stats = fs.statSync(filePath);
              return {
                filename: f,
                path: path.relative(workspaceRoot, filePath),
                size: stats.size,
                createdAt: stats.birthtime.toISOString(),
                format: path.extname(f).slice(1)
              };
            })
            .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
            .slice(0, limit);

          return {
            success: true,
            files,
            total: files.length,
            exportDir: path.relative(workspaceRoot, fullOutputDir)
          };

        } catch (error) {
          throw new Error(`ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: ${error.message}`);
        }
      }
    }
  ];
}
